1) Shadows of the Knight - Episode 1(Medium):
Решение посредством бинарного поиска, работаем на плоскости, так что задано 4 
указателя, на каждой итерации получаем направление для 
движения и сдвигаем область поиска, отталкиваясь от позиции игрока, считаем новые координаты для него от высоты и ширины сдвинутой области(как среднее). Используем флаги, чтобы при движении в одном направлении не двигаться в другом.
2) Shadows of the Knight - Episode 2(Very hard):
Мы задаём две области поиска: по оси x и y, первоначально они включают в себя все возможные индексы-координаты, на основе получаемого ввода от системы по новой позиции x(к первой итерации это не относится), мы выполняем сужение рассматриваемой области по осям. Например, если мы получаем "WARMER", то оставляем только те позиции, которые ближе к новой позиции, чем к предыдущей(т.к. среди именно этих индексов находится целевой). Аналогично, если получили "COLDER", то оставим те индексы, которые ближе к предыдущей позиции. Если получили "SAME", то значит расстояние до цели не изменилось после перемещения, зная это, мы можем оставить только те индексы, которые аналогично цели(среди них цель) находятся на равных расстояниях к предыдущей и текущей позиции. После сужения области поиска мы проверяем не нашли ли мы целевую ячейку, запоминаем текущую позицию как предыдущую и выполняем обновление текущей позиции. Новую позицию мы подбираем так, чтобы среднее области поиска было равно среднему между позициями, т.е. (prev_x + x) / 2 = (xs[0] + xs.back()) / 2. Таким образом после получения сообщения на основе новой позиции мы будем делить нашу область поиска как бы надвое относительно среднего(часть ближе к предыдущей и часть ближе к текущей позиции). При этом мы сначала работаем только с x-ом и после переходим к y. При граничных случаях формула не работает, эмпирически от результатов тестов, я беру здесь среднее от области поиска. После обновления координаты, выводим результат, чтобы получить по нему новое сообщение. Когда сужать область поиска уже некуда, мы находимся в целевой ячейке.
3) There is no Spoon(Medium):
Создаём две функции: для поиска соседа справа и для поиска соседа снизу. Сетка инициализируется как вектор строк, соответственно при поиске справа перебираем второй индекс, проходясь по строке, при поиске снизу перебираем первый индекс, проходясь по строкам. Функции возвращают пары: координаты x и y. После нахождения первого необходимого элемента, используем функции, ища соседей.
