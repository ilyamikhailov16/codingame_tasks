1) Shadows of the Knight - Episode 1(Medium):
Решение посредством бинарного поиска, работаем на плоскости, так что задано 4 
указателя, на каждой итерации получаем направление для 
движения и сдвигаем область поиска, отталкиваясь от позиции игрока, считаем новые координаты для него от высоты и ширины сдвинутой области(как среднее). Используем флаги, чтобы при движении в одном направлении не двигаться в другом.
https://www.codingame.com/training/expert/shadows-of-the-knight-episode-1

2) Shadows of the Knight - Episode 2(Very hard):
Мы задаём две области поиска: по оси x и y, первоначально они включают в себя все возможные индексы-координаты, на основе получаемого ввода от системы по новой позиции x(к первой итерации это не относится), мы выполняем сужение рассматриваемой области по осям. Например, если мы получаем "WARMER", то оставляем только те позиции, которые ближе к новой позиции, чем к предыдущей(т.к. среди именно этих индексов находится целевой). Аналогично, если получили "COLDER", то оставим те индексы, которые ближе к предыдущей позиции. Если получили "SAME", то значит расстояние до цели не изменилось после перемещения, зная это, мы можем оставить только те индексы, которые аналогично цели(среди них цель) находятся на равных расстояниях к предыдущей и текущей позиции. После сужения области поиска мы проверяем не нашли ли мы целевую ячейку, запоминаем текущую позицию как предыдущую и выполняем обновление текущей позиции. Новую позицию мы подбираем так, чтобы среднее области поиска было равно среднему между позициями, т.е. (prev_x + x) / 2 = (xs[0] + xs.back()) / 2. Таким образом после получения сообщения на основе новой позиции мы будем делить нашу область поиска как бы надвое относительно среднего(часть ближе к предыдущей и часть ближе к текущей позиции). При этом мы сначала работаем только с x-ом и после переходим к y. При граничных случаях формула не работает, эмпирически от результатов тестов, я беру здесь среднее от области поиска. После обновления координаты, выводим результат, чтобы получить по нему новое сообщение. Когда сужать область поиска уже некуда, мы находимся в целевой ячейке.
https://www.codingame.com/training/expert/shadows-of-the-knight-episode-2

3) There is no Spoon - Episode 1(Medium):
Создаём две функции: для поиска соседа справа и для поиска соседа снизу. Сетка инициализируется как вектор строк, соответственно при поиске справа перебираем второй индекс, проходясь по строке, при поиске снизу перебираем первый индекс, проходясь по строкам. Функции возвращают пары: координаты x и y. После нахождения первого необходимого элемента, используем функции, ища соседей.
https://www.codingame.com/training/medium/there-is-no-spoon-episode-1

4) Stock Exchange Losses(Medium):
Мы хотим найти максимальный убыток, который можно получить при торговле акциями. Для этого мы проходимся по массиву цен, отслеживая максимальную цену (peak_price), достигнутую до текущего дня. Затем вычисляем потенциальный убыток, если продать акции по текущей цене. Максимальный убыток обновляется, если текущий убыток оказывается меньше(т.к. работаем с отрицательными числами, т.е. больше по модулю).  Обновляем пиковую цену, если текущая цена выше. 
https://www.codingame.com/training/medium/stock-exchange-losses

5) Death First Search - Episode 1(Medium). Работаем с графом, который представляем в виде вектора пар(т.е. ребёр), пара хранит индексы элементов, которые связаны между собой. Также используем вектор, который заполняем булевыми значениями, для определения целевых элементов, по их индексу будем получать true. В игровом цикле while проходимся через for по парам и проверяем элементы пары на соответствие основному условию задачи, чтобы найти желаемую пару, в случае выполнения условия мы завершаем игру, иначе проходимся вторым циклом по парам и проверяем их на соответствие второму условию из задачи и выводим тогда вторую по приоритету пару.
https://www.codingame.com/training/medium/death-first-search-episode-1

